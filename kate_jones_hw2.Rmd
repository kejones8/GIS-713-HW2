---
title: "Kate_Jones_HW2"
output: pdf
---
**Question 1**
```{r setup, include=FALSE,echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)

###figure out how to tidy the margins, set tidy=TRUE??

library(data.table)
library(rgdal)
library(raster)
library(RColorBrewer)

#setwd
setwd("C:\\Users\\The Brain\\OneDrive - North Carolina State University\\F2019 - Classes\\GIS 713\\HW\\GIS-713-HW2\\")

#read in data, added .tif extension to kansas_sub file to get it to read properly
#read landsat image in as a stack, to get all 6 bands
kansas_sub<-raster::stack(".\\kansas_sub.tif")
kansas_2011_cdl<-raster::raster(".\\kansas_sub_2011_CDL.tif")
samp_pnts<-readOGR(dsn=".\\sample_points",layer="sample_points")

#go ahead and reproject samp_pnts
lat_long<-"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
utm_proj<-"+proj=utm +zone=14 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 "

#define current CRS for samp_pnts
proj4string(samp_pnts) <- CRS(lat_long)
#then transform
samp_pnts_utm <- spTransform(samp_pnts, CRS(utm_proj))

#notes on ndvi:
#NDVI= (nir-r)/(r+nir)
#NDVI = (Band 4 â€“ Band 3) / (Band 4 + Band 3)
###do i need to do raster::calc() here? 
ndvi<-(kansas_sub[[4]]-kansas_sub[[3]])/(kansas_sub[[4]]+kansas_sub[[3]])

#number of pixels in cld for each crop class
pix_table<-as.data.frame(table(getValues(kansas_2011_cdl)))
#get crop classes that have more than 1e4 pixels
pix_10000<-pix_table[pix_table$Freq>=10000,]
crop_numbers<-as.character(pix_10000$Var1)

#referenced from: 
#https://www.nass.usda.gov/Research_and_Science/Cropland/
#metadata/2017_cultivated_layer_metadata.htm
#create a character vector (based on above crop_numbers) 
#to more easily name box plots
crop_names<-c("corn","sorghum","soybeans","winter wheat",
              "alfalfa","fallow or idle cropland",
              "pasture/grass","developed/open space",
              "pasture/hay")


#could automate this

##the variable numbers do not align with the query statements..need to fix
ndvi_crop1<-ndvi[kansas_2011_cdl==1]
ndvi_crop3<-ndvi[kansas_2011_cdl==4]
ndvi_crop4<-ndvi[kansas_2011_cdl==5]
ndvi_crop6<-ndvi[kansas_2011_cdl==24]
ndvi_crop11<-ndvi[kansas_2011_cdl==36]
ndvi_crop14<-ndvi[kansas_2011_cdl==61]
ndvi_crop15<-ndvi[kansas_2011_cdl==62]
ndvi_crop17<-ndvi[kansas_2011_cdl==121]
ndvi_crop24<-ndvi[kansas_2011_cdl==181]

#boxplot the results for each vector
plot.new()
boxplot(ndvi_crop1,ndvi_crop3,ndvi_crop4,ndvi_crop6,
        ndvi_crop11,ndvi_crop14,ndvi_crop15,ndvi_crop17,
        ndvi_crop24,
        col=brewer.pal(n = 9, name = "Set3"),
        main = "NDVI across Multiple Crops",
        border = "black",
        cex.lab=.75,
        cex.axis=.5,
        xlab="CLD type",
        ylab="NDVI",
        las=3,
        names=crop_names,
        outcex=.4,
        notch = TRUE
)

```

## R Markdown
```{r,echo = FALSE}

library(maptools)

#crop the ndvi layer to the smaller extent of the points
crop_ndvi_pnts<-raster::crop(ndvi,samp_pnts_utm)
crop_stack_pnts<-raster::crop(kansas_sub,samp_pnts_utm)
#extract the ndvi values to the points
pnts_vals<-raster::extract(ndvi,samp_pnts_utm)
#cbind these values to the samp_pnts_utm
samp_pnts_utm$ndvi<-round(pnts_vals,3)
#how to label points within map


################GET IAN's PLOTTING CODE

#creates a plot with 2 rows, 1 column
par(mfrow = c(2, 1))

qs <- quantile(raster(crop_stack_pnts, 4), c(0, 0.02, 0.98, 1))
breaks <- unique(c(qs[1], seq(qs[2], qs[3], len=254), qs[4]))
pal <- colorRampPalette(rev(brewer.pal(11, "Spectral")))

plotRGB(crop_stack_pnts,r=5,b=4,g=3,margins=TRUE,axes=TRUE,cex.axis=.5,stretch="lin",main="False Color: Bands 5,4,3")#, breaks=breaks, col=pal(length(breaks) - 1),axes=TRUE, stretch="lin")
plot(samp_pnts_utm,pch=16,cex=.25,add=T)
maptools::pointLabel(samp_pnts_utm@coords,labels = as.character(samp_pnts_utm$ndvi), cex = 0.5)
#text(samp_pnts_utm@coords, labels=as.character(samp_pnts_utm$ID), 
#     cex=0.5, pos=3)

#qs <- quantile(raster(crop_ndvi_pnts, 5), c(-.1, 0, 0.25, .5,.75))
breaks <- unique(c(qs[1], seq(qs[2], qs[3], len=254), qs[5]))
pal <- colorRampPalette(rev(brewer.pal(11, "Spectral")))
#plot(raster(crop_ndvi_pnts, 4), breaks=breaks, col=pal(length(breaks) - 1))


plot(crop_ndvi_pnts,box=FALSE,axes=TRUE,legend=TRUE,main="NDVI")#,breaks=breaks, col=pal(length(breaks) - 1), stretch="lin")
box(col = "white") 
plot(samp_pnts_utm,pch=16,cex=.25,add=T)
maptools::pointLabel(samp_pnts_utm@coords,labels = as.character(samp_pnts_utm$ndvi), cex = 0.5)
#text(samp_pnts_utm@coords, as.character(samp_pnts_utm$ndvi), cex=0.5, pos=3)

```


```{r,echo = FALSE}
#get the x & y extent of the subset
extent(crop_ndvi_pnts)
#generate 1e4 random x's
x_coords <- sample(362765.5:375426.3,10025,replace=T)
#generate 1e4 random y's
y_coords<-  sample(4177944.01:4187036.01,10025,replace=T)

#make these coordinates into a spatial points dataframe
coords<-cbind(x_coords,y_coords)
points_df<-SpatialPoints(coords)

#extra ndvi values at the points locations
ndvi_at_rand<-extract(crop_ndvi_pnts,points_df)
#make ndvi values a variable in the spatial points dataframe
points_df$ndvi<-ndvi_at_rand

proj4string(points_df) <- CRS(utm_proj)
#then transform
points_df_utm <- spTransform(points_df, CRS(utm_proj))

#plot using spplot
spplot(points_df_utm,"ndvi",pch=16,cex=.5)

```


```{r , echo = FALSE}
library(gstat)
library(spatstat)
library(Metrics)
library(geoR)
library(lattice)
library(latticeExtra)
library(forecast)

pnts_utm_nona<-points_df_utm[!is.na(points_df_utm$ndvi),]
#pnts_utm_nd <- remove.duplicates(pnts_utm)
x<-pnts_utm_nona@coords[,1]
y<-pnts_utm_nona@coords[,2]
pnts_utm_nona$x<-x
pnts_utm_nona$y<-y

#create blank grid 
blank.grid<-spsample(samp_pnts_utm,type="regular",n=10000)

#start with IDW, power of 1
idwmodel = idw(ndvi ~1, pnts_utm_nona,samp_pnts_utm, maxdist = Inf)#, idp = 2) 
#add idw calculations to samp_pnts_utm
samp_pnts_utm$idw_ndvi<-idwmodel$var1.pred
samp_idw_acc<-forecast::accuracy(samp_pnts_utm$ndvi,samp_pnts_utm$idw_ndvi)

# calculates sample variogram values 
vario <- variogram((ndvi)~1, pnts_utm_nona)
#check out which model is best? ###why doesn't this work??
test.vario <- fit.variogram(vario, vgm(c("Exp","Sph","Gau")))
### need to tweak model fit, most likely?
fit.vario <- fit.variogram(vario, model=vgm(.5, "Sph", 700))#, 1)) # fit model
### plot empirical vs. model
plot(vario, fit.vario ,main = "ordinary kriging")

#annotating the variogram....
annotated_plot<-
        plot(vario,model=fit.vario,lwd=2,col.line="black",pch=16,cex=0.5,ylim=c(0,.5),
                     xlim=c(0,5000),
                     main=list("Spherical Semivariogram Model for NDVI Predictions",
                     xlab=list("Distance between Point Pairs (m)"),cex=2 ),
                     ylab=list("Semivariance"),
                     scales=list(x=list(at=c(0,100,500,1000,5000),
                                        labels=c(0,100,500,1000,5000)),
                     y=list(at=c(0,0.5,.1,.15,.2,.25,.3),
                            labels=c(0,"",.15,"",.25,"")),cex=2),
                     key=
                     list(text=list(lab=c("Spherical Model","Sill","Maximum Interpolation                            Distance")),
                     space="top",lines=list(col=c("black","black","red"),
                                            lwd=2,lty=c(1,2,1)),columns=3,cex=1.5))

#use trellis so the plot doesn't close
plot(annotated_plot)
lattice::trellis.focus("panel",1,1)
plot(annotated_plot)
lattice::trellis.focus("panel",1,1)
llines(x=c(500,500),y=c(0,.5),col="red",lwd=2,lty=1)
llines(x=c(0,500),y=c(.5,.5),col="red",lwd=2,lty=1)
llines(x=c(0,500),y=c(fit.vario$psill[2]+fit.vario$psill[1],fit.vario$psill[2]+fit.vario[1]),col="black",lty=2,lwd=2)
ltext(x=12,y=5,"Nuggest~ unk",cex=1.5)
trellis.unfocus()

                     
#create blank grid 
blank.grid<-spsample(samp_pnts_utm,type="regular",n=10000)

#write the kriging function
gs <- gstat(formula=ndvi~1, locations=pnts_utm_nona,model=fit.vario)#, nmax=5, set=list(idp = 0))
#interpolate the kriging information to the created blank grid
krig_ndvi <- predict(gs,blank.grid)

#set to dataframe
krig.output = as.data.frame(krig_ndvi)
#assign column names
names(krig.output)[1:3] <- c("x", "y", "prediction")

spg <- krig.output
#confirm
coordinates(spg) <- ~ x + y

# coerce to SpatialPixelsDataFrame
gridded(spg) <- TRUE
# coerce to raster
raster_krig <- raster(spg)

# sets projection to British National Grid
projection(raster_krig) <- CRS(utm_proj)

# we can quickly plot the raster to check its okay
plot(raster_krig)

#get krigged values @ 44 sample points
krig_ndvi_atsamps<-raster::extract(raster_krig,samp_pnts_utm)
#add them to the sample points df
samp_pnts_utm$krig_ndvi<-krig_ndvi_atsamps

samp_krig_acc<-forecast::accuracy(samp_pnts_utm$ndvi,samp_pnts_utm$krig_ndvi)
##interesting, RMSE barely improves with 1000 grid

####Need to answer in more depth the last questions

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
