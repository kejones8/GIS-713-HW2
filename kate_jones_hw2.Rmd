---
title: "Kate_Jones_HW2"
output:
  pdf_document: default
---
**Question 1**
```{r setup, include=FALSE,echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)

###figure out how to tidy the margins, set tidy=TRUE??

library(data.table)
library(rgdal)
library(raster)
library(RColorBrewer)

#setwd
setwd("C:\\Users\\The Brain\\OneDrive - North Carolina State University\\F2019 - Classes\\GIS 713\\HW\\GIS-713-HW2\\")

#read in data, added .tif extension to kansas_sub file to get it to read properly
#read landsat image in as a stack, to get all 6 bands
kansas_sub<-raster::stack(".\\kansas_sub.tif")
kansas_2011_cdl<-raster::raster(".\\kansas_sub_2011_CDL.tif")
samp_pnts<-readOGR(dsn=".\\sample_points",layer="sample_points")

#go ahead and reproject samp_pnts
lat_long<-"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
utm_proj<-"+proj=utm +zone=14 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 "

#define current CRS for samp_pnts
proj4string(samp_pnts) <- CRS(lat_long)
#then transform
samp_pnts_utm <- spTransform(samp_pnts, CRS(utm_proj))

#notes on ndvi:
#NDVI= (nir-r)/(r+nir)
#NDVI = (Band 4 â€“ Band 3) / (Band 4 + Band 3)
###do i need to do raster::calc() here? 
ndvi<-(kansas_sub[[4]]-kansas_sub[[3]])/(kansas_sub[[4]]+kansas_sub[[3]])

#number of pixels in cld for each crop class
pix_table<-as.data.frame(table(getValues(kansas_2011_cdl)))
#get crop classes that have more than 1e4 pixels
pix_10000<-pix_table[pix_table$Freq>=10000,]
crop_numbers<-as.character(pix_10000$Var1)

#referenced from: 
#https://www.nass.usda.gov/Research_and_Science/Cropland/
#metadata/2017_cultivated_layer_metadata.htm
#create a character vector (based on above crop_numbers) 
#to more easily name box plots
crop_names<-c("corn","sorghum","soybeans","winter wheat",
              "alfalfa","fallow or idle cropland",
              "pasture/grass","developed/open space",
              "pasture/hay")


#could automate this

##the variable numbers do not align with the query statements..need to fix
ndvi_crop1<-ndvi[kansas_2011_cdl==1]
ndvi_crop3<-ndvi[kansas_2011_cdl==4]
ndvi_crop4<-ndvi[kansas_2011_cdl==5]
ndvi_crop6<-ndvi[kansas_2011_cdl==24]
ndvi_crop11<-ndvi[kansas_2011_cdl==36]
ndvi_crop14<-ndvi[kansas_2011_cdl==61]
ndvi_crop15<-ndvi[kansas_2011_cdl==62]
ndvi_crop17<-ndvi[kansas_2011_cdl==121]
ndvi_crop24<-ndvi[kansas_2011_cdl==181]

#boxplot the results for each vector
plot.new()
boxplot(ndvi_crop1,ndvi_crop3,ndvi_crop4,ndvi_crop6,
        ndvi_crop11,ndvi_crop14,ndvi_crop15,ndvi_crop17,
        ndvi_crop24,
        col=brewer.pal(n = 9, name = "Set3"),
        main = "NDVI across Multiple Crops",
        border = "black",
        cex.lab=.75,
        cex.axis=.5,
        xlab="CLD type",
        ylab="NDVI",
        las=3,
        names=crop_names,
        outcex=.4,
        notch = TRUE
)

```

## R Markdown
```{r,echo = FALSE}

library(maptools)
library(viridis)

#crop the ndvi layer to the smaller extent of the points
crop_ndvi_pnts<-raster::crop(ndvi,samp_pnts_utm)
crop_stack_pnts<-raster::crop(kansas_sub,samp_pnts_utm)
#extract the ndvi values to the points
pnts_vals<-raster::extract(ndvi,samp_pnts_utm)
#cbind these values to the samp_pnts_utm
samp_pnts_utm$ndvi<-round(pnts_vals,3)
#how to label points within map


# plot rasters side by side with more plotting commands
# than i've ever wanted to know
op<-par(no.readonly=TRUE)
par(op)
par(mfrow=c(1,2))
par(yaxt="t",#remove from y
    xaxt='t')#remove from x

par(oma=c(3,3,3,3),mar=c(2,1,2,1)+0.1)

qs <- quantile(crop_ndvi_pnts, c(0, 0.02, 0.98, 1))
toplot_breaks <- unique(c(qs[1], seq(qs[2], qs[3], len=254), qs[5]))
toplot_pal<-colorRampPalette(plasma(100))

PlotStretchLegend(crop_ndvi_pnts,toplot_breaks,toplot_pal,box=FALSE,axes=FALSE)
mtext(text="UTM Northing",side=2,line=-.5,outer=TRUE,cex=1)
par(tcl=1,mgp=c(1.5,.25,0))
axis(side=2,at=c(4177944,4187036),lwd=.25,lwd.ticks=.25,col.ticks="black",las=2,cex.axis=.75)
par(tcl=5,mgp=c(0,-.5,-1.8))
axis(side=1,at=c(362770,375426),lwd=.25,lwd.ticks=.25,col.ticks="black",las=2,cex.axis=.75)#,line=0,inner=TRUE)
mtext(text="UTM Easting",side=1,line=-.5,cex=1)
mtext(text="NDVI",side=3,line=2,cex=2)
plot(samp_pnts_utm,pch=16,cex=.5,col="white",add=T)
maptools::pointLabel(samp_pnts_utm@coords,labels = as.character(samp_pnts_utm$ndvi), cex = 0.6,col="white")




plotRGB(crop_stack_pnts,r=5,b=4,g=3,margins=TRUE,axes=FALSE,cex.axis=.5,stretch="lin")#,main="False Color: Bands 5,4,3")
mtext(text="False Color: 5,4,3",side=3,line=2,cex=2)
mtext(text="UTM Northing",side=4,line=0,outer=TRUE,cex=1)
par(tcl=1,mgp=c(1.5,.25,0))
axis(side=4,at=c(4177944,4187036),lwd=.25,lwd.ticks=.25,col.ticks="black",las=2,cex.axis=.75)
par(tcl=5,mgp=c(0,-.5,-1.5))
axis(side=1,at=c(362770,375426),lwd=.25,lwd.ticks=.25,col.ticks="black",las=2,cex.axis=.75)#,line=0,inner=TRUE)
mtext(text="UTM Easting",side=1,line=-.5,cex=1)


plot(samp_pnts_utm,pch=3,cex=.3,add=T)
maptools::pointLabel(samp_pnts_utm@coords,labels = as.character(samp_pnts_utm$ndvi), cex = 0.6)


# PlotStretchLegend <- function(r, breaks, pal, ...){
#   # this function assumes that you've applied some sort of LINEAR CONTRAST
#   # stretch (i.e. 2% stretch). The legend will be WRONG if you applied some
#   # other nonlinear stretch (e.g. histogram equalization)
#   plot(r, col=pal(length(breaks) - 1), breaks=breaks, xaxt="n", yaxt="n", legend=F, ...)
#   # add a reasonable legend
#   legend_at <- round(seq(breaks[2], breaks[length(breaks) - 1], len=7))
#   legend_labels <- c(paste("<", legend_at[1]), as.character(legend_at[2:(length(legend_at) - 1)]), paste(">", legend_at[length(legend_at)]))
#   plot(raster(matrix(legend_at[1]:legend_at[length(legend_at)])), legend.only=T, col=pal(length(breaks)-1), axis.args=list(at=legend_at, labels=legend_labels))
# }


```


```{r,echo = FALSE}
#get the x & y extent of the subset
extent(crop_ndvi_pnts)
#generate 1e4 random x's
x_coords <- sample(362765.5:375426.3,10025,replace=T)
#generate 1e4 random y's
y_coords<-  sample(4177944.01:4187036.01,10025,replace=T)

#make these coordinates into a spatial points dataframe
coords<-cbind(x_coords,y_coords)
points_df<-SpatialPoints(coords)

#extra ndvi values at the points locations
ndvi_at_rand<-extract(crop_ndvi_pnts,points_df)
#make ndvi values a variable in the spatial points dataframe
points_df$ndvi<-ndvi_at_rand

proj4string(points_df) <- CRS(utm_proj)
#then transform
points_df_utm <- spTransform(points_df, CRS(utm_proj))

#plot using spplot
spplot(points_df_utm,"ndvi",pch=16,cex=.5)

```


```{r , echo = FALSE}
library(gstat)
library(spatstat)
library(Metrics)
library(geoR)
library(lattice)
library(latticeExtra)
library(forecast)

pnts_utm_nona<-points_df_utm[!is.na(points_df_utm$ndvi),]
#pnts_utm_nd <- remove.duplicates(pnts_utm)
x<-pnts_utm_nona@coords[,1]
y<-pnts_utm_nona@coords[,2]
pnts_utm_nona$x<-x
pnts_utm_nona$y<-y

#create blank grid 
blank.grid<-spsample(samp_pnts_utm,type="regular",n=10000)

#start with IDW, power of 1
idwmodel = gstat::idw(ndvi ~1, pnts_utm_nona,samp_pnts_utm, maxdist = Inf)#, idp = 2) 
#add idw calculations to samp_pnts_utm
samp_pnts_utm$idw_ndvi<-idwmodel$var1.pred
samp_idw_acc<-forecast::accuracy(samp_pnts_utm$ndvi,samp_pnts_utm$idw_ndvi)
plot_idw_acc<-samp_idw_acc[c(1:length(samp_idw_acc))]

# calculates sample variogram values 
vario <- variogram((ndvi)~1, pnts_utm_nona)

#returns spherical??
#try this one instead of autofit
test.fits<-fit.variogram(vario, vgm(c("Exp", "Mat", "Sph")))

### need to tweak model fit, most likely?
fit.vario <- fit.variogram(vario, model=vgm(fit.vario$psill[2], "Sph", fit.vario$range[2],fit.vario$psill[1]))#, 1)) # fit model
### plot empirical vs. model
plot(vario, fit.vario ,main = "ordinary kriging")

#annotating the variogram....
annotated_plot<-
        plot(vario,model=fit.vario,lwd=2,col.line="black",pch=16,cex=0.5,ylim=c(0,.04),
             xlim=c(0,4000),
             main=list(
                     "Spherical Semivariogram Model for NDVI Predictions",
                     xlab=list("Distance between Point Pairs (m)"),cex=1 ),
             ylab=list("Semivariance"),
             scales=list(x=list(at=c(0,1000,2000,3000,4000),
                                labels=c(0,1000,2000,3000,4000)),
                         y=list(at=c(0,0.05,.01,.015,.02,.025,.03,.035,.04),
                                #keep getting NA after last label
                                labels=c(0,"",.015,"",.025,"",.035,"",.045)),cex=1),
             key=
                     list(text=list(lab=c("Spherical Model","Sill",
                                          "Maximum Interpolation Distance")),
                          space="top",lines=list(col=c("black","black","red"),
                                                 lwd=2,lty=c(1,2,1)),columns=3,cex=.75))

#use trellis so the plot doesn't close
plot(annotated_plot)
lattice::trellis.focus("panel",1,1)
plot(annotated_plot)
lattice::trellis.focus("panel",1,1)
###should automate these lines to extract from the model values for plotting...
llines(x=c(fit.vario$range[2],fit.vario$range[2]),y=c(0,fit.vario$psill[2]),col="red",lwd=2,lty=1)
#llines(x=c(0,925),y=c(.035,.035),col="red",lwd=2,lty=1)
llines(x=c(0,fit.vario$range[2]),y=c(fit.vario$psill[2]+fit.vario$psill[1],fit.vario$psill[2]+fit.vario$psill[1]),col="black",lty=2,lwd=2)
ltext(x=500,y=.005*.75,paste("Nugget ~",round(fit.vario$psill[1],3),sep=""),cex=.75)
ltext(x=fit.vario$range[2]+50,y=.015,paste("Range ~",round(fit.vario$range[2],0),sep=""),cex=.75,srt=90)
trellis.unfocus()


#create blank grid 
blank.grid<-spsample(samp_pnts_utm,type="regular",n=10000)

#write the kriging function
gs <- gstat(formula=ndvi~1, locations=pnts_utm_nona,model=fit.vario)#, nmax=5, set=list(idp = 0))
#interpolate the kriging information to the created blank grid
krig_ndvi <- predict(gs,blank.grid)

#set to dataframe
krig.output = as.data.frame(krig_ndvi)
#assign column names
names(krig.output)[1:3] <- c("x", "y", "prediction")

spg <- krig.output
#confirm
coordinates(spg) <- ~ x + y

# coerce to SpatialPixelsDataFrame
gridded(spg) <- TRUE
# coerce to raster
raster_krig <- raster(spg)

# sets projection to British National Grid
projection(raster_krig) <- CRS(utm_proj)

# we can quickly plot the raster to check its okay
plot(raster_krig)

#get krigged values @ 44 sample points
krig_ndvi_atsamps<-raster::extract(raster_krig,samp_pnts_utm)
#add them to the sample points df
samp_pnts_utm$krig_ndvi<-krig_ndvi_atsamps

samp_krig_acc<-forecast::accuracy(samp_pnts_utm$ndvi,samp_pnts_utm$krig_ndvi)


plot_krig_acc<-samp_krig_acc[c(1:length(samp_krig_acc))]

####Need to answer in more depth the last questions

```


```{r, echo=FALSE}
#error_names<-c("ME","RMSE","MAE","MPE","MAPE")
plot(plot_idw_acc,col="blue",cex=2,ylab="Error Values",xaxt='n')
mtext(text="ME                     RMSE                       MAE                    MPE                        MAPE",side=1,line=0,cex=1)     
points(plot_krig_acc,col="red",pch=8)
mtext(text="Error Metrics",side=1,line=2,cex=1)

par(mfrow=c(1,2))
####fit a slope line to these
plot(samp_pnts_utm$idw_ndvi,samp_pnts_utm$ndvi)

plot(samp_pnts_utm$krig_ndvi,samp_pnts_utm$ndvi)

```
